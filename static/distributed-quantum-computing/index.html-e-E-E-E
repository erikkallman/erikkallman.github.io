<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Distributed Quantum Computing</title>
    <link rel="stylesheet" href="../assets/built/screen.css%3Fv=a931d041cb.css">

    <link rel="canonical" href="index.html" />
    <meta name="referrer" content="no-referrer-when-downgrade" />
    
    <meta property="og:site_name" content="Black-sky Albedo" />
    <meta property="og:type" content="article" />
    <meta property="og:title" content="Distributed Quantum Computing" />
    <meta property="og:description" content="Massive investments are being made in the European landscape of quantum computing. The question is what frameworks that enable orchestration of calculations to only deploy the most optimal problem formulation on the most suitable piece of hardware.


Problem statement

As a researcher and innovator in the quantum life-science area, I" />
    <meta property="og:url" content="erikkallman.github.io/distributed-quantum-computing/" />
    <meta property="og:image" content="erikkallman.github.io/content/images/2024/10/Screenshot-2024-10-16-at-13.03.05.png" />
    <meta property="article:published_time" content="2024-12-04T09:20:38.000Z" />
    <meta property="article:modified_time" content="2024-12-04T09:24:46.000Z" />
    <meta property="article:publisher" content="https://www.facebook.com/ghost" />
    <meta name="twitter:card" content="summary_large_image" />
    <meta name="twitter:title" content="Distributed Quantum Computing" />
    <meta name="twitter:description" content="Massive investments are being made in the European landscape of quantum computing. The question is what frameworks that enable orchestration of calculations to only deploy the most optimal problem formulation on the most suitable piece of hardware.


Problem statement

As a researcher and innovator in the quantum life-science area, I" />
    <meta name="twitter:url" content="erikkallman.github.io/distributed-quantum-computing/" />
    <meta name="twitter:image" content="erikkallman.github.io/content/images/2024/10/Screenshot-2024-10-16-at-13.03.05.png" />
    <meta name="twitter:label1" content="Written by" />
    <meta name="twitter:data1" content="Erik Källman" />
    <meta name="twitter:site" content="@ghost" />
    <meta property="og:image:width" content="2000" />
    <meta property="og:image:height" content="1312" />
    
    <script type="application/ld+json">
{
    "@context": "https://schema.org",
    "@type": "Article",
    "publisher": {
        "@type": "Organization",
        "name": "Black-sky Albedo",
        "url": "erikkallman.github.io/",
        "logo": {
            "@type": "ImageObject",
            "url": "erikkallman.github.io/favicon.ico",
            "width": 48,
            "height": 48
        }
    },
    "author": {
        "@type": "Person",
        "name": "Erik Källman",
        "url": "erikkallman.github.io/author/erik/",
        "sameAs": []
    },
    "headline": "Distributed Quantum Computing",
    "url": "erikkallman.github.io/distributed-quantum-computing/",
    "datePublished": "2024-12-04T09:20:38.000Z",
    "dateModified": "2024-12-04T09:24:46.000Z",
    "image": {
        "@type": "ImageObject",
        "url": "erikkallman.github.io/content/images/2024/10/Screenshot-2024-10-16-at-13.03.05.png",
        "width": 2000,
        "height": 1312
    },
    "description": "Massive investments are being made in the European landscape of quantum computing. The question is what frameworks that enable orchestration of calculations to only deploy the most optimal problem formulation on the most suitable piece of hardware.\n\n\nProblem statement\n\nAs a researcher and innovator in the quantum life-science area, I want to be able to develop or test an algorithm locally on my laptop and iteratively expand on it in terms of parameters, noise models used, systems analysed etc. I",
    "mainEntityOfPage": {
        "@type": "WebPage",
        "@id": "erikkallman.github.io/"
    }
}
    </script>

    <meta name="generator" content="Ghost 5.24" />
    <link rel="alternate" type="application/rss+xml" title="Black-sky Albedo" href="../rss/index.html" />
    <script defer src="https://cdn.jsdelivr.net/ghost/portal@~2.20/umd/portal.min.js" data-ghost="erikkallman.github.io/" data-key="a7bfe472616e25a965e4ed9698" data-api="erikkallman.github.io/ghost/api/content/" crossorigin="anonymous"></script><style id="gh-members-styles">.gh-post-upgrade-cta-content,
.gh-post-upgrade-cta {
    display: flex;
    flex-direction: column;
    align-items: center;
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
    text-align: center;
    width: 100%;
    color: #ffffff;
    font-size: 16px;
}

.gh-post-upgrade-cta-content {
    border-radius: 8px;
    padding: 40px 4vw;
}

.gh-post-upgrade-cta h2 {
    color: #ffffff;
    font-size: 28px;
    letter-spacing: -0.2px;
    margin: 0;
    padding: 0;
}

.gh-post-upgrade-cta p {
    margin: 20px 0 0;
    padding: 0;
}

.gh-post-upgrade-cta small {
    font-size: 16px;
    letter-spacing: -0.2px;
}

.gh-post-upgrade-cta a {
    color: #ffffff;
    cursor: pointer;
    font-weight: 500;
    box-shadow: none;
    text-decoration: underline;
}

.gh-post-upgrade-cta a:hover {
    color: #ffffff;
    opacity: 0.8;
    box-shadow: none;
    text-decoration: underline;
}

.gh-post-upgrade-cta a.gh-btn {
    display: block;
    background: #ffffff;
    text-decoration: none;
    margin: 28px 0 0;
    padding: 8px 18px;
    border-radius: 4px;
    font-size: 16px;
    font-weight: 600;
}

.gh-post-upgrade-cta a.gh-btn:hover {
    opacity: 0.92;
}</style>
    <script defer src="https://cdn.jsdelivr.net/ghost/sodo-search@~1.1/umd/sodo-search.min.js" data-key="a7bfe472616e25a965e4ed9698" data-styles="https://cdn.jsdelivr.net/ghost/sodo-search@~1.1/umd/main.css" data-sodo-search="erikkallman.github.io/" crossorigin="anonymous"></script>
    <script defer src="../public/cards.min.js%3Fv=a931d041cb"></script>
    <link rel="stylesheet" type="text/css" href="../public/cards.min.css%3Fv=a931d041cb.css">
    <script defer src="../public/member-attribution.min.js%3Fv=a931d041cb"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.x.x/themes/prism.min.css" />

    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/katex.min.css" crossorigin="anonymous">
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/katex.min.js" crossorigin="anonymous"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/contrib/auto-render.min.js" crossorigin="anonymous"
  onload="renderMathInElement(document.body, {
    delimiters: [
      {left: '$$', right: '$$', display: true},
      {left: '\\(', right: '\\)', display: false}, // Inline math using \( \)
      {left: '\\[', right: '\\]', display: true}   // Display math using \[ \]
    ]
  });"></script>
<style>:root {--ghost-accent-color: #7f7f7f;}</style>
</head>

<body class="post-template  is-head-left-logo">
<div class="site">

    <header id="gh-head" class="gh-head gh-outer">
        <div class="gh-head-inner gh-inner">
            <div class="gh-head-brand">
                <div class="gh-head-brand-wrapper">
                    <a class="gh-head-logo" href="../index.html">
                            Black-sky Albedo
                    </a>
                </div>
                <button class="gh-search gh-icon-btn" data-ghost-search><svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M17.5 17.5L12.5 12.5L17.5 17.5ZM14.1667 8.33333C14.1667 9.09938 14.0158 9.85792 13.7226 10.5657C13.4295 11.2734 12.9998 11.9164 12.4581 12.4581C11.9164 12.9998 11.2734 13.4295 10.5657 13.7226C9.85792 14.0158 9.09938 14.1667 8.33333 14.1667C7.56729 14.1667 6.80875 14.0158 6.10101 13.7226C5.39328 13.4295 4.75022 12.9998 4.20854 12.4581C3.66687 11.9164 3.23719 11.2734 2.94404 10.5657C2.65088 9.85792 2.5 9.09938 2.5 8.33333C2.5 6.78624 3.11458 5.30251 4.20854 4.20854C5.30251 3.11458 6.78624 2.5 8.33333 2.5C9.88043 2.5 11.3642 3.11458 12.4581 4.20854C13.5521 5.30251 14.1667 6.78624 14.1667 8.33333Z" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
</svg>
</button>
                <button class="gh-burger"></button>
            </div>

            <nav class="gh-head-menu">
                <ul class="nav">
    <li class="nav-home"><a href="../index.html">Home</a></li>
    <li class="nav-about"><a href="../about/index.html">About</a></li>
</ul>

            </nav>

            <div class="gh-head-actions">
                    <button class="gh-search gh-icon-btn" data-ghost-search><svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M17.5 17.5L12.5 12.5L17.5 17.5ZM14.1667 8.33333C14.1667 9.09938 14.0158 9.85792 13.7226 10.5657C13.4295 11.2734 12.9998 11.9164 12.4581 12.4581C11.9164 12.9998 11.2734 13.4295 10.5657 13.7226C9.85792 14.0158 9.09938 14.1667 8.33333 14.1667C7.56729 14.1667 6.80875 14.0158 6.10101 13.7226C5.39328 13.4295 4.75022 12.9998 4.20854 12.4581C3.66687 11.9164 3.23719 11.2734 2.94404 10.5657C2.65088 9.85792 2.5 9.09938 2.5 8.33333C2.5 6.78624 3.11458 5.30251 4.20854 4.20854C5.30251 3.11458 6.78624 2.5 8.33333 2.5C9.88043 2.5 11.3642 3.11458 12.4581 4.20854C13.5521 5.30251 14.1667 6.78624 14.1667 8.33333Z" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
</svg>
</button>
                            <a class="gh-head-btn gh-btn gh-primary-btn" href="index.html#/portal/signup" data-portal="signup">Subscribe</a>
            </div>
        </div>
    </header>


    <div class="site-content">
        
<main class="site-main">


    <article class="post">

        <header class="gh-article-header gh-canvas">
            <h1 class="gh-article-title">Distributed Quantum Computing</h1>
            <div class="post-meta">
                Last updated on&nbsp;
                <time datetime="2024-12-04">Dec 4, 2024</time>
            </div>
                <figure class="gh-article-image">
        <img
            class="post-image"
            srcset="../content/images/size/w400/2024/10/Screenshot-2024-10-16-at-13.03.05.png 400w,
                   ../content/images/size/w750/2024/10/Screenshot-2024-10-16-at-13.03.05.png 750w,
                  ../content/images/size/w960/2024/10/Screenshot-2024-10-16-at-13.03.05.png 960w,
                 ../content/images/size/w1140/2024/10/Screenshot-2024-10-16-at-13.03.05.png 1140w,
                ../content/images/size/w1920/2024/10/Screenshot-2024-10-16-at-13.03.05.png.png 1920w"
            sizes="(min-width: 1200px) 960px, 92vw"
            src="../content/images/size/w960/2024/10/Screenshot-2024-10-16-at-13.03.05.png"
            alt="Distributed Quantum Computing"
        >
    </figure>
        </header>

        <div class="gh-content gh-canvas">
            <p>Massive investments are being made in the European landscape of quantum computing. The question is what frameworks that enable orchestration of calculations to only deploy the most optimal problem formulation on the most suitable piece of hardware. </p><h2 id="problem-statement"><strong>Problem statement</strong></h2><p>As a researcher and innovator in the quantum life-science area, I want to be able to develop or test an algorithm locally on my laptop and iteratively expand on it in terms of parameters, noise models used, systems analysed etc. I want to define a grid of parameters, something like:</p><!--kg-card-begin: markdown--><pre><code class="language-python">hyperparam_grid = [
    {
        'optimizer_type': 'COBYLA',
        'optimizer_steps': 50,
        'tol': 1e-3
    },
    {
        'optimizer_type': 'SPSA',
        'optimizer_steps': 50,
        'learning_rate': 0.1
    },
    ...
]</code></pre>
<!--kg-card-end: markdown--><p>over which i want to find the optimal combination with respect to evaluation criteria. From this, a test deployment on a actual quantum computer backend would be made. I would then like to collect details on the calculation and build a "profile" of calculations over different European compute backends. </p><p>Moreover, ideally I would like to be able to create workflows where i can use whatever code i like for calculating integrals and different pieces of data required for my calculations and that parts of these workflows can be executed in parallell over processes that are interdependent.  In pseudo-pseudo code:</p><!--kg-card-begin: markdown--><h4 id="define">Define:</h4>
<ul>
<li><code>ansatz_types = ['TwoLocal', 'EfficientSU2']</code></li>
<li><code>optimizers = ['COBYLA', 'SPSA']</code></li>
<li><code>hyperparams_list = [{'optimizer_steps': 10, 'optimizer_params': {'tol': 1e-3}}, ... ]</code></li>
<li><code>noise_models = ['depolarizing', 'bit_flip']</code></li>
</ul>
<h4 id="for-each-ansatztype">For each <code>ansatz_type</code>:</h4>
<ul>
<li>Create and append <code>ansatz_spec</code> (function: <code>prepare_ansatz</code>, dependencies: <code>[&quot;assemble_hamiltonian&quot;]</code>)</li>
</ul>
<h4 id="for-each-optimizer">For each <code>optimizer</code>:</h4>
<ul>
<li>Set <code>vqe_dependencies = [&quot;prepare_ansatz_&lt;ansatz_type&gt;&quot;]</code></li>
<li>Create <code>nodename_prefix = &quot;run_vqe_&lt;ansatz_type&gt;_&lt;optimizer&gt;&quot;</code></li>
</ul>
<h4 id="for-each-hyperparams">For each <code>hyperparams</code>:</h4>
<ul>
<li>Create and append <code>vqe_spec</code> (function: <code>run_vqe_simulation</code>, dependencies: <code>vqe_dependencies</code>, optimizer: <code>optimizer</code>, hyperparams: <code>hyperparams</code>)</li>
<li>Set <code>noise_dependencies = [vqe_spec.node_name]</code></li>
<li>Create <code>noise_nodename_prefix = &quot;apply_noise_&lt;vqe_spec.node_name&gt;&quot;</code></li>
</ul>
<h4 id="for-each-noisemodel">For each <code>noise_model</code>:</h4>
<ul>
<li>Create and append <code>noise_spec</code> (function: <code>apply_noise_model</code>, dependencies: <code>noise_dependencies</code>, noise_model: <code>noise_model</code>, ansatz_type: <code>ansatz_type</code>)</li>
</ul>
<!--kg-card-end: markdown--><p>Such that for each wavefunction anzats we get a workflow of dependencies according to:</p><figure class="kg-card kg-image-card"><img src="../content/images/2024/10/quantum_workflow_graph_neat_highres-1.png" class="kg-image" alt loading="lazy" width="1483" height="1067" srcset="../content/images/size/w600/2024/10/quantum_workflow_graph_neat_highres-1.png 600w, ../content/images/size/w1000/2024/10/quantum_workflow_graph_neat_highres-1.png 1000w, ../content/images/2024/10/quantum_workflow_graph_neat_highres-1.png 1483w" sizes="(min-width: 720px) 720px"></figure><p>Where the hamiltonian is assembled for the particular system and calculation in mind, preferably in a manner where the one and two electron integrals can be calculated using a code of choice.</p><h2 id="solution"><strong>Solution</strong></h2><p><a href="https://ar5iv.labs.arxiv.org/html/2403.16486">ColonyOS</a> is a meta-operating system that simplifies the execution of workloads across diverse and distributed computing environments, including cloud, edge, HPC, and IoT. This makes it ideal for managing the complex, resource-intensive tasks associated with distributed quantum computing. It is Open Source Software (MIT License) and is <a href="https://github.com/colonyos/colonies">available on github</a> for inspection and download. There are some <a href="https://github.com/colonyos/tutorials">great tutorial notebooks</a> to get started.<br><br>ColonyOS supports:</p><h3 id="distributed-microservice-architectures">Distributed Microservice Architectures</h3><p>ColonyOS is built on a microservices model, where small, independent executors handle specific tasks. This approach supports the distributed nature of quantum computing, where quantum tasks (e.g., operations on quantum processors) may need to be executed across geographically separated quantum and classical computing resources. Executors are deployed independently and scaled horizontally, ensuring efficient parallel processing and fault tolerance.</p><h3 id="workflow-orchestration">Workflow Orchestration</h3><p>The platform allows users to define complex, multi-step workflows across distributed executors. This is crucial for quantum computing workflows, which often involve iterative processes like quantum circuit execution, optimization steps (e.g., in VQE algorithms), and hybrid quantum-classical computations. ColonyOS manages the dependencies and execution order, ensuring smooth operation across different systems.</p><h3 id="scalability-and-fault-tolerance">Scalability and Fault Tolerance</h3><p>Quantum computing systems require robust fault tolerance due to the probabilistic nature of quantum states and the potential for node failures in distributed setups. ColonyOS supports automatic re-assignment of tasks to healthy executors if one fails, making it highly resilient to issues that might disrupt quantum computation across distributed nodes.</p><h3 id="platform-agnostic-integration">Platform-Agnostic Integration</h3><p>ColonyOS’s ability to operate across various platforms, including cloud and HPC environments, aligns with the hybrid quantum-classical infrastructure often required for quantum computing. This allows ColonyOS to orchestrate tasks that need to run on both classical supercomputers and quantum processors.</p><p>In summary, ColonyOS's distributed architecture, task orchestration capabilities, scalability, and fault tolerance make it a strong choice for managing the complexities of distributed quantum computing, where tasks need to be efficiently coordinated across a range of quantum and classical computing environments.</p><h2 id="implementation"><strong>Implementation</strong></h2><p>The attempt made in this post is to describe the use of ColonyOS as an orchestrator for quantum computation tasks. The focus is on solving a simpler problem (a water ground state energy calculation) to illustrate the potential of the orchestrator and what it could mean for the distributed aspects of quantum computing. </p><h3 id="what-is-measured-to-evaluate-the-calculations">What Is Measured to Evaluate the Calculations</h3><p>Besides runtimes and ground state energy values generated from the calculations,, estimating how noise affects quantum circuits is important. To evaluate the performance of quantum circuits under noisy conditions, there are numerous metrics that can be used. In the present work the implementation covers <strong>Shannon Entropy</strong> and <strong>Jensen-Shannon Divergence (JSD) </strong>as a starting point. A few sections below will be used to elaborate on this using qiskit as a reference.</p><h4 id="noise-modeling-in-qiskit">Noise Modeling in Qiskit</h4><p><strong>Qiskit</strong> provides various tools for simulating quantum circuits under various noise models. In this context, two common noise models are employed and described below.</p><h5 id="1-depolarizing-noise-model">1. Depolarizing Noise Model</h5><p>The depolarizing noise model represents a scenario where the quantum state loses its coherence and becomes a completely mixed state with a certain probability. Mathematically, for a single-qubit state \(\rho\), the depolarizing channel \(\mathcal{E}_{\text{dep}}\) is defined as:</p><p>\[ \mathcal{E}_{\text{dep}}(\rho) = (1 - p) \rho + p \frac{I}{2} \]where:</p><ul><li>\(p\) is the depolarizing probability (error rate),</li><li>\(I\) is the identity matrix representing the maximally mixed state.</li></ul><p>For multi-qubit systems, the depolarizing channel generalizes by applying the noise independently to each qubit or collectively to the entire system, depending on the model specifics.</p><p>In Qiskit, the depolarizing noise is added to quantum gates like single-qubit rotations (<code>u3</code>) and two-qubit gates (<code>cx</code>) using the <code>depolarizing_error</code> function:</p><pre><code class="language-python">depolarizing_error_1q = noise.depolarizing_error(p, 1)
depolarizing_error_2q = noise.depolarizing_error(p, 2)
</code></pre><p>Every gate operation is followed by the application of the depolarizing channel \(\mathcal{E}_{\text{dep}}\) with a specified probability. This simulates the randomization of the qubit state due to interactions with the environment.</p><p>For example, after applying a gate \(U\), the state \(\rho'\) becomes:</p><p>$$\rho' = \mathcal{E}_{\text{dep}}(U \rho U^\dagger) = (1 - p) U \rho U^\dagger + p \frac{I}{2}$$</p><p>This process increases the mixedness of the quantum state, leading to higher entropy in the output distribution.</p><h5 id="2-bit-flip-noise-model">2. Bit-Flip Noise Model</h5><p>The bit-flip noise model simulates the error where a qubit flips its state from \(|0\rangle\) to \(|1\rangle\) or vice versa, akin to a classical bit flip. The bit-flip channel \(\mathcal{E}_{\text{bf}}\) for a single qubit is defined as:</p><p>$$\mathcal{E}_{\text{bf}}(\rho) = (1 - p) \rho + p X \rho X^\dagger$$</p><p><strong>where</strong></p><ul><li>\(X\) is the Pauli-X operator.</li><li>\(p\) is the probability of a bit-flip error.</li></ul><p>In the context of two-qubit gates, an error might flip both qubits simultaneously, represented by: $$ X \otimes X $$</p><p>In Qiskit, bit-flip errors are introduced using the <code>pauli_error</code> function:</p><pre><code class="language-python">bit_flip_error_1q = noise.pauli_error([('X', p), ('I', 1 - p)])
bit_flip_error_2q = noise.pauli_error([('XX', p), ('II', 1 - p)])
</code></pre><p>In this model, the qubit state is flipped with a certain probability after each gate operation. The effect on the state \(\rho\) is:</p><p>$$\rho' = \mathcal{E}_{\text{bf}}(U \rho U^\dagger) = (1 - p) U \rho U^\dagger + p X U \rho U^\dagger X^\dagger$$</p><p>This introduces specific errors corresponding to bit flips, altering the probabilities of measuring certain outcomes, and thereby changing the output distribution.</p><p>By analyzing the noise output distributions from the simulations one should be able to analyse how:</p><ul><li><strong>Depolarizing Noise</strong> tends to make the distribution more uniform due to the randomization of states, leading to a higher entropy increase.</li><li><strong>Bit-Flip Noise</strong> causes specific transitions between states, resulting in a redistribution of probabilities that may not uniformly increase entropy but can significantly change the distribution shape, as captured by the JSD.</li></ul><h4 id="measuring-the-impact-of-noise">Measuring the Impact of Noise</h4><p>To quantify how noise affects the quantum circuit, we analyze the output probability distributions of the circuit under noiseless and noisy conditions using the following metrics:</p><h5 id="shannon-entropy">Shannon Entropy</h5><p>Shannon Entropy measures the uncertainty or randomness in a probability distribution. For a discrete random variable with possible outcomes \({x_i}\) and corresponding probabilities \({p_i}\), the Shannon entropy \(H\) is defined as:</p><p>$$H(X) = -\sum_{i} p_i \log_2 p_i$$</p><p>In the context of quantum circuits, the entropy of the output distribution indicates how spread out the measurement outcomes are:</p><ul><li><strong>Low Entropy</strong>: The distribution is concentrated on specific outcomes, implying less uncertainty.</li><li><strong>High Entropy</strong>: The distribution is more uniform, indicating higher uncertainty and randomness, often due to noise.</li></ul><p>By calculating the entropy of both the noiseless \(H_{\text{noiseless}}\) and noisy \(H_{\text{noisy}}\) output distributions, we can assess the increase in uncertainty introduced by noise.</p><h5 id="jensen-shannon-divergence-jsd">Jensen-Shannon Divergence (JSD)</h5><p>The <strong>Jensen-Shannon Divergence</strong> is a method of measuring the similarity between two probability distributions. It is a symmetrized and smoothed version of the Kullback-Leibler divergence and is always bounded between 0 and 1 when using log base 2.</p><p>For two probability distributions \(P = {p_i}\) and \(Q = {q_i}\), the JSD is defined as:</p><p>$$\text{JSD}(P \parallel Q) = \frac{1}{2} D_{\text{KL}}(P \parallel M) + \frac{1}{2} D_{\text{KL}}(Q \parallel M)$$</p><p>where:</p><ul><li>\(M = \frac{1}{2}(P + Q)\) is the average distribution,  </li><li>\(D_{\text{KL}}(P \parallel M)\) is the Kullback-Leibler divergence from \(P\) to \(M\):</li></ul><p>$$D_{\text{KL}}(P \parallel M) = \sum_{i} p_i \log_2 \left( \frac{p_i}{m_i} \right)$$</p><p>The JSD effectively measures how much the noisy distribution deviates from the noiseless distribution:</p><ul><li><strong>JSD = 0</strong>: The distributions are identical.</li><li><strong>Higher JSD Values</strong>: Indicate greater divergence between the distributions due to noise.</li></ul><h4 id="applying-the-metrics-to-evaluate-noise-impact">Applying the Metrics to Evaluate Noise Impact</h4><p>By computing the Shannon entropy and JSD for the output distributions, we gain quantitative insights into the noise's effect:</p><p><strong>Entropy Difference (\(\Delta H\)):</strong></p><p>$$\Delta H = H_{\text{noisy}} - H_{\text{noiseless}}$$</p><p><strong>Interpretation:</strong> A positive \(\Delta H\) suggests that noise has increased the uncertainty in the output distribution.</p><p><strong>Entropy Ratio:</strong></p><p>$$\text{Entropy Ratio} = \frac{H_{\text{noisy}}}{H_{\text{noiseless}}}$$</p><p><strong>Interpretation</strong>: Provides a relative measure of entropy increase.</p><p><strong>Jensen-Shannon Divergence</strong>:</p><ul><li>Directly compares the noisy and noiseless distributions, highlighting the overall change in distribution shape.</li></ul><h4 id="practical-implications-of-the-metrics">Practical Implications of the Metrics</h4><ul><li><strong>Algorithm Performance</strong>: Lower entropy difference and JSD values imply that the quantum circuit's performance is closer to the ideal case, with noise having a minimal effect.</li><li><strong>Noise Model Assessment</strong>: By comparing metrics across different noise models (depolarizing vs. bit-flip), we can evaluate which types of noise have more detrimental effects on the circuit.</li><li><strong>Optimization Strategies</strong>: Understanding how specific noise types impact the circuit guides the development of error mitigation techniques and circuit optimization.</li></ul><h3 id="ranking-and-the-calculation-graph">Ranking and the Calculation Graph</h3><p>The ColonyOS workflow calculation serializes qiskit objects as well as metrics and metadata from each part of the workflow into a sqlite database. This database is then exposed to localhost by a simple Flask API. That flask API is connected to a React frontend that exposes to key views of the results data, detailed below. Both views show the same data and allow ranking across a set of metrics, but do so in different ways.</p><h4 id="the-metrics-table">The Metrics table</h4><p>The metrics table is a simple (in development) table that simply displays each noise simulation computation and data from its related VQE simulation.</p><figure class="kg-card kg-image-card"><img src="../content/images/2024/12/Screenshot-2024-12-03-at-14.07.22.png" class="kg-image" alt loading="lazy" width="2000" height="962" srcset="../content/images/size/w600/2024/12/Screenshot-2024-12-03-at-14.07.22.png 600w, ../content/images/size/w1000/2024/12/Screenshot-2024-12-03-at-14.07.22.png 1000w, ../content/images/size/w1600/2024/12/Screenshot-2024-12-03-at-14.07.22.png 1600w, ../content/images/size/w2400/2024/12/Screenshot-2024-12-03-at-14.07.22.png 2400w" sizes="(min-width: 720px) 720px"></figure><h4 id="the-workflow-graph">The Workflow Graph</h4><p>The workflow graph shows how each step in the workflow is connected and which steps are dependent on its information. </p><figure class="kg-card kg-image-card"><img src="../content/images/2024/12/Screenshot-2024-12-03-at-14.19.04.png" class="kg-image" alt loading="lazy" width="2000" height="962" srcset="../content/images/size/w600/2024/12/Screenshot-2024-12-03-at-14.19.04.png 600w, ../content/images/size/w1000/2024/12/Screenshot-2024-12-03-at-14.19.04.png 1000w, ../content/images/size/w1600/2024/12/Screenshot-2024-12-03-at-14.19.04.png 1600w, ../content/images/size/w2400/2024/12/Screenshot-2024-12-03-at-14.19.04.png 2400w" sizes="(min-width: 720px) 720px"></figure><p>Here, the legend tells what part of the calculation workflow the nodes correspond to, and a node information panel displays metrics of the selected node. It allows one to compute a ranking across nodes (similar to the metrics table) and rescales as well as labels the nodes as a function of rank, as can be seen below.</p><figure class="kg-card kg-image-card"><img src="../content/images/2024/12/Screenshot-2024-12-03-at-14.20.18.png" class="kg-image" alt loading="lazy" width="2000" height="990" srcset="../content/images/size/w600/2024/12/Screenshot-2024-12-03-at-14.20.18.png 600w, ../content/images/size/w1000/2024/12/Screenshot-2024-12-03-at-14.20.18.png 1000w, ../content/images/size/w1600/2024/12/Screenshot-2024-12-03-at-14.20.18.png 1600w, ../content/images/size/w2400/2024/12/Screenshot-2024-12-03-at-14.20.18.png 2400w" sizes="(min-width: 720px) 720px"></figure><p>While this is interesting and useful for smaller calculation like this, one can imagine what such a database could present if the graph could provide easily searchable sets of data. Graph structures readily fit into graph learning algorithms as well, opening up the possibility of predicting calculation graph result estimates based on input to get a first order approximation of what may be good parameters to explore for the given system.</p><h3 id="summary">Summary</h3><p>The ambition of this was to show what is work in progress in terms of using a state of the art orchestrator for distributed computing for the use case of quantum computation. Furthermore, to use graph data analytics to view and analyse computation results. Future work remains to be published.<br><br>For a presentation on ColonyOS and what specific problems it is meant to solve check out this presentation that i held at the <a href="https://enccs.github.io/qas2024/">Quantum Autumn School 2024</a>.</p><hr><p><strong>References:</strong></p><ol><li>Nielsen, M. A., &amp; Chuang, I. L. (2010). <em>Quantum Computation and Quantum Information</em>. Cambridge University Press.</li><li><a href="https://qiskit.github.io/qiskit-aer/apidocs/aer_noise.html">Qiskit Documentation for noise modules in Aer</a></li><li>Shannon, C. E. (1948). A Mathematical Theory of Communication. <em>Bell System Technical Journal</em>, 27(3), 379–423.</li></ol><h3></h3>
        </div>

        <div class="pagination-container gh-canvas">
        <nav class="pagination">

            <div class="pagination-left">
                    <a class="newer-posts" href="../containerized-sen2cor-processing/index.html">
                        <span class="pagination-label">Previous</span>
                        The Sen2cor Processing Handbook
                    </a>
            </div>

            <div class="pagination-right">
            </div>

        </nav>
        </div>


    </article>


</main>
    </div>

    <footer class="gh-foot gh-outer">
        <div class="gh-foot-inner gh-inner">
            <div class="gh-copyright">
                Black-sky Albedo © 2024
            </div>
            <nav class="gh-foot-menu">
                <ul class="nav">
    <li class="nav-sign-up"><a href="index.html#/portal/">Sign up</a></li>
</ul>

            </nav>
            <div class="gh-powered-by">
                <a href="https://ghost.org/" target="_blank" rel="noopener">Powered by Ghost</a>
            </div>
        </div>
    </footer>

</div>

    <div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">
    <div class="pswp__bg"></div>

    <div class="pswp__scroll-wrap">
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <div class="pswp__ui pswp__ui--hidden">
            <div class="pswp__top-bar">
                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
                <button class="pswp__button pswp__button--share" title="Share"></button>
                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)"></button>
            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)"></button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>
        </div>
    </div>
</div>
<script
    src="https://code.jquery.com/jquery-3.3.1.min.js"
    integrity="sha256-FgpCb/KJQlLNfOu91ta32o/NMZxltwRo8QtmkMRdAu8="
    crossorigin="anonymous">
</script>
<script src="../assets/built/main.min.js%3Fv=a931d041cb"></script>

<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.x.x/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.x.x/components/prism-python.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.x.x/components/prism-rust.min.js"></script>

</body>
</html>